package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"google.golang.org/genai"
)

func readFile(path string) (string, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(b), nil
}

func main() {
	ctx := context.Background()
	client, err := genai.NewClient(ctx, nil)
	if err != nil {
		log.Fatal(err)
	}

	// Define the tool
	tools := []*genai.Tool{
		{
			FunctionDeclarations: []*genai.FunctionDeclaration{
				{
					Name:        "readFile",
					Description: "Read the contents of a file",
					Parameters: &genai.Schema{
						Type: genai.TypeObject,
						Properties: map[string]*genai.Schema{
							"path": {
								Type:        genai.TypeString,
								Description: "The path to the file to read",
							},
						},
						Required: []string{"path"},
					},
				},
			},
		},
	}

	config := &genai.GenerateContentConfig{
		Tools: tools,
		ThinkingConfig: &genai.ThinkingConfig{
			IncludeThoughts: true,
		},
	}

	prompt := "Read the file 'go.mod' and tell me how what version is used for go in this project"
	model := "gemini-2.5-flash"

	// Initial history
	history := []*genai.Content{
		{
			Role: "user",
			Parts: []*genai.Part{
				{Text: prompt},
			},
		},
	}

	for {
		resp := client.Models.GenerateContentStream(
			ctx,
			model,
			history,
			config,
		)

		var currentResponseParts []*genai.Part
		var functionCalls []*genai.FunctionCall

		for chunk, err := range resp {
			if err != nil {
				log.Fatal(err)
			}

			for _, part := range chunk.Candidates[0].Content.Parts {
				currentResponseParts = append(currentResponseParts, part)

				if part.FunctionCall != nil {
					functionCalls = append(functionCalls, part.FunctionCall)
				} else if part.Thought {
					fmt.Printf("\n[Thinking]: %s", part.Text)
				} else {
					fmt.Printf("%s", part.Text)
				}
			}
		}
		modelResponseHistory := &genai.Content{
			Role:  "model",
			Parts: currentResponseParts,
		}
		history = append(history, modelResponseHistory)

		if len(functionCalls) == 0 {
			// No more functions to call, we are done!
			break
		}

		for _, fn := range functionCalls {
			fmt.Printf("Calling tool: %s\n", fn.Name)

			var content string
			if fn.Name == "readFile" {
				path, ok := fn.Args["path"].(string)
				if !ok {
					content = "Error: invalid argument 'path'"
				} else {
					c, err := readFile(path)
					if err != nil {
						content = fmt.Sprintf("Error: %v", err)
					} else {
						content = c
					}
				}
			} else {
				content = fmt.Sprintf("Error: unknown tool %s", fn.Name)
			}
			functionResponseHistory := &genai.Content{
				Role: "user",
				Parts: []*genai.Part{{
					FunctionResponse: &genai.FunctionResponse{
						Name:     fn.Name,
						Response: map[string]any{"content": content},
					},
				}},
			}
			history = append(history, functionResponseHistory)
		}

		// Loop repeats: The next iteration sends the function results back to the model
	}

	// provider := google.New() -- or google.New(google.WithApiKey(key string))
	// model := provider.Model(ctx, "gemini-2.5-pro")
	//
}
